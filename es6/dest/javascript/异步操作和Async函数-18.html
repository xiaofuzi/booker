<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>
        
	异步操作和Async函数

    </title>
    <link rel="shortcut icon" href="/booker/es6/dest/public/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="/booker/es6/dest/public/css/public.css">
    <link rel="stylesheet" href="/booker/es6/dest/public/css/page.css">
    <link rel="stylesheet" href="/booker/es6/dest/public/css/monokai.min.css">
</head>

<body>
    <div id="headerWrapper" class="cf">
        <header id="header" class="cf">
            <div id="logo">
                <h1 class="logo">
					<a href="/"> 
	Learn ECMAScript6 the easy way
</a>
				</h1>
            </div>
        </header>
    </div>
    
<div id="pageWrapper">
	<div id="mainContent">
		<article class="post">
			<h1 id="-async-">异步操作和Async函数</h1>
<p>异步编程对JavaScript语言太重要。JavaScript只有一根线程，如果没有异步编程，根本没法用，非卡死不可。</p>
<p>ES6诞生以前，异步编程的方法，大概有下面四种。</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<p>ES6将JavaScript异步编程带入了一个全新的阶段，ES7的<code>Async</code>函数更是提出了异步编程的终极解决方案。</p>
<h2 id="-">基本概念</h2>
<h3 id="-">异步</h3>
<p>所谓&quot;异步&quot;，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<h3 id="-">回调函数</h3>
<p>JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是&quot;重新调用&quot;。</p>
<p>读取文件进行处理，是这样写的。</p>
<pre><code class="lang-javascript">fs.readFile(&#39;/etc/passwd&#39;, function (err, data) {
  if (err) throw err;
  console.log(data);
});
</code></pre>
<p>上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p>
<p>一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p>
<h3 id="promise">Promise</h3>
<p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p>
<pre><code class="lang-javascript">fs.readFile(fileA, function (err, data) {
  fs.readFile(fileB, function (err, data) {
    // ...
  });
});
</code></pre>
<p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为“回调函数噩梦”（callback hell）。</p>
<p>Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。</p>
<pre><code class="lang-javascript">var readFile = require(&#39;fs-readfile-promise&#39;);

readFile(fileA)
.then(function(data){
  console.log(data.toString());
})
.then(function(){
  return readFile(fileB);
})
.then(function(data){
  console.log(data.toString());
})
.catch(function(err) {
  console.log(err);
});
</code></pre>
<p>上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</p>
<p>可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p>
<p>Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。</p>
<p>那么，有没有更好的写法呢？</p>
<h2 id="generator-">Generator函数</h2>
<h3 id="-">协程</h3>
<p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做&quot;协程&quot;（coroutine），意思是多个线程互相协作，完成异步任务。</p>
<p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p>
<ul>
<li>第一步，协程A开始执行。</li>
<li>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</li>
<li>第三步，（一段时间后）协程B交还执行权。</li>
<li>第四步，协程A恢复执行。</li>
</ul>
<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p>
<p>举例来说，读取文件的协程写法如下。</p>
<pre><code class="lang-javascript">function asnycJob() {
  // ...其他代码
  var f = yield readFile(fileA);
  // ...其他代码
}
</code></pre>
<p>上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。</p>
<p>协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<h3 id="generator-">Generator函数的概念</h3>
<p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。</p>
<pre><code class="lang-javascript">function* gen(x){
  var y = yield x + 2;
  return y;
}

var g = gen(1);
g.next() // { value: 3, done: false }
g.next() // { value: undefined, done: true }
</code></pre>
<p>上面代码中，调用Generator函数，会返回一个内部指针（即遍历器）g 。这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到<code>x + 2</code>为止。</p>
<p>换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。</p>
<h3 id="generator-">Generator函数的数据交换和错误处理</h3>
<p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p>
<p>next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。</p>
<pre><code class="lang-javascript">function* gen(x){
  var y = yield x + 2;
  return y;
}

var g = gen(1);
g.next() // { value: 3, done: false }
g.next(2) // { value: 2, done: true }
</code></pre>
<p>上面代码中，第一个next方法的value属性，返回表达式<code>x + 2</code>的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。</p>
<p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>
<pre><code class="lang-javascript">function* gen(x){
  try {
    var y = yield x + 2;
  } catch (e){
    console.log(e);
  }
  return y;
}

var g = gen(1);
g.next();
g.throw（&#39;出错了&#39;）;
// 出错了
</code></pre>
<p>上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try ...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
<h3 id="-">异步任务的封装</h3>
<p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>
<pre><code class="lang-javascript">var fetch = require(&#39;node-fetch&#39;);

function* gen(){
  var url = &#39;https://api.github.com/users/github&#39;;
  var result = yield fetch(url);
  console.log(result.bio);
}
</code></pre>
<p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</p>
<p>执行这段代码的方法如下。</p>
<pre><code class="lang-javascript">var g = gen();
var result = g.next();

result.value.then(function(data){
  return data.json();
}).then(function(data){
  g.next(data);
});
</code></pre>
<p>上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。</p>
<p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h2 id="thunk-">Thunk函数</h2>
<h3 id="-">参数的求值策略</h3>
<p>Thunk函数早在上个世纪60年代就诞生了。</p>
<p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是&quot;求值策略&quot;，即函数的参数到底应该何时求值。</p>
<pre><code class="lang-javascript">var x = 1;

function f(m){
  return m * 2;
}

f(x + 5)
</code></pre>
<p>上面代码先定义函数f，然后向它传入表达式<code>x + 5</code>。请问，这个表达式应该何时求值？</p>
<p>一种意见是&quot;传值调用&quot;（call by value），即在进入函数体之前，就计算<code>x + 5</code>的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。</p>
<pre><code class="lang-javascript">f(x + 5)
// 传值调用时，等同于
f(6)
</code></pre>
<p>另一种意见是&quot;传名调用&quot;（call by name），即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。Hskell语言采用这种策略。</p>
<pre><code class="lang-javascript">f(x + 5)
// 传名调用时，等同于
(x + 5) * 2
</code></pre>
<p>传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p>
<pre><code class="lang-javascript">function f(a, b){
  return b;
}

f(3 * x * x - 2 * x - 1, x);
</code></pre>
<p>上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于&quot;传名调用&quot;，即只在执行时求值。</p>
<h3 id="thunk-">Thunk函数的含义</h3>
<p>编译器的&quot;传名调用&quot;实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。</p>
<pre><code class="lang-javascript">function f(m){
  return m * 2;
}

f(x + 5);

// 等同于

var thunk = function () {
  return x + 5;
};

function f(thunk){
  return thunk() * 2;
}
</code></pre>
<p>上面代码中，函数f的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。
这就是Thunk函数的定义，它是&quot;传名调用&quot;的一种实现策略，用来替换某个表达式。</p>
<h3 id="javascript-thunk-">JavaScript语言的Thunk函数</h3>
<p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p>
<pre><code class="lang-javascript">// 正常版本的readFile（多参数版本）
fs.readFile(fileName, callback);

// Thunk版本的readFile（单参数版本）
var readFileThunk = Thunk(fileName);
readFileThunk(callback);

var Thunk = function (fileName){
  return function (callback){
    return fs.readFile(fileName, callback);
  };
};
</code></pre>
<p>上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。</p>
<p>任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。</p>
<pre><code class="lang-javascript">var Thunk = function(fn){
  return function (){
    var args = Array.prototype.slice.call(arguments);
    return function (callback){
      args.push(callback);
      return fn.apply(this, args);
    }
  };
};
</code></pre>
<p>使用上面的转换器，生成<code>fs.readFile</code>的Thunk函数。</p>
<pre><code class="lang-javascript">var readFileThunk = Thunk(fs.readFile);
readFileThunk(fileA)(callback);
</code></pre>
<h3 id="thunkify-">Thunkify模块</h3>
<p>生产环境的转换器，建议使用Thunkify模块。</p>
<p>首先是安装。</p>
<pre><code class="lang-bash">$ npm install thunkify
</code></pre>
<p>使用方式如下。</p>
<pre><code class="lang-javascript">var thunkify = require(&#39;thunkify&#39;);
var fs = require(&#39;fs&#39;);

var read = thunkify(fs.readFile);
read(&#39;package.json&#39;)(function(err, str){
  // ...
});
</code></pre>
<p>Thunkify的源码与上一节那个简单的转换器非常像。</p>
<pre><code class="lang-javascript">function thunkify(fn){
  return function(){
    var args = new Array(arguments.length);
    var ctx = this;

    for(var i = 0; i &lt; args.length; ++i) {
      args[i] = arguments[i];
    }

    return function(done){
      var called;

      args.push(function(){
        if (called) return;
        called = true;
        done.apply(null, arguments);
      });

      try {
        fn.apply(ctx, args);
      } catch (err) {
        done(err);
      }
    }
  }
};
</code></pre>
<p>它的源码主要多了一个检查机制，变量<code>called</code>确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。</p>
<pre><code class="lang-javascript">function f(a, b, callback){
  var sum = a + b;
  callback(sum);
  callback(sum);
}

var ft = thunkify(f);
var print = console.log.bind(console);
ft(1, 2)(print);
// 3
</code></pre>
<p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出一行结果。</p>
<h3 id="generator-">Generator 函数的流程管理</h3>
<p>你可能会问， Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理。</p>
<p>以读取文件为例。下面的Generator函数封装了两个异步操作。</p>
<pre><code class="lang-javascript">var fs = require(&#39;fs&#39;);
var thunkify = require(&#39;thunkify&#39;);
var readFile = thunkify(fs.readFile);

var gen = function* (){
  var r1 = yield readFile(&#39;/etc/fstab&#39;);
  console.log(r1.toString());
  var r2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(r2.toString());
};
</code></pre>
<p>上面代码中，yield命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。</p>
<p>这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数。</p>
<pre><code class="lang-javascript">var g = gen();

var r1 = g.next();
r1.value(function(err, data){
  if (err) throw err;
  var r2 = g.next(data);
  r2.value(function(err, data){
    if (err) throw err;
    g.next(data);
  });
});
</code></pre>
<p>上面代码中，变量g是Generator函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。</p>
<p>仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。</p>
<h3 id="thunk-">Thunk函数的自动流程管理</h3>
<p>Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。</p>
<pre><code class="lang-javascript">function run(fn) {
  var gen = fn();

  function next(err, data) {
    var result = gen.next(data);
    if (result.done) return;
    result.value(next);
  }

  next();
}

run(gen);
</code></pre>
<p>上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done 属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出。</p>
<p>有了这个执行器，执行Generator函数方便多了。不管有多少个异步操作，直接传入<code>run</code>函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在<code>yield</code>命令后面的必须是Thunk函数。</p>
<pre><code class="lang-javascript">var gen = function* (){
  var f1 = yield readFile(&#39;fileA&#39;);
  var f2 = yield readFile(&#39;fileB&#39;);
  // ...
  var fn = yield readFile(&#39;fileN&#39;);
};

run(gen);
</code></pre>
<p>上面代码中，函数<code>gen</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>
<p>Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p>
<h2 id="co-">co模块</h2>
<h3 id="-">基本用法</h3>
<p><a href="https://github.com/tj/co">co模块</a>是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。</p>
<p>比如，有一个Generator函数，用于依次读取两个文件。</p>
<pre><code class="lang-javascript">var gen = function* (){
  var f1 = yield readFile(&#39;/etc/fstab&#39;);
  var f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
};
</code></pre>
<p>co模块可以让你不用编写Generator函数的执行器。</p>
<pre><code class="lang-javascript">var co = require(&#39;co&#39;);
co(gen);
</code></pre>
<p>上面代码中，Generator函数只要传入co函数，就会自动执行。</p>
<p>co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p>
<pre><code class="lang-javascript">co(gen).then(function (){
  console.log(&#39;Generator 函数执行完成&#39;);
})
</code></pre>
<p>上面代码中，等到Generator函数执行结束，就会输出一行提示。</p>
<h3 id="co-">co模块的原理</h3>
<p>为什么co可以自动执行Generator函数？</p>
<p>前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以做到这一点。</p>
<p>（1）回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。</p>
<p>（2）Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。</p>
<p>co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。</p>
<p>上一节已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。</p>
<h3 id="-promise-">基于Promise对象的自动执行</h3>
<p>还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。</p>
<pre><code class="lang-javascript">var fs = require(&#39;fs&#39;);

var readFile = function (fileName){
  return new Promise(function (resolve, reject){
    fs.readFile(fileName, function(error, data){
      if (error) reject(error);
      resolve(data);
    });
  });
};

var gen = function* (){
  var f1 = yield readFile(&#39;/etc/fstab&#39;);
  var f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
};
</code></pre>
<p>然后，手动执行上面的Generator函数。</p>
<pre><code class="lang-javascript">var g = gen();

g.next().value.then(function(data){
  g.next(data).value.then(function(data){
    g.next(data);
  });
})
</code></pre>
<p>手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>
<pre><code class="lang-javascript">function run(gen){
  var g = gen();

  function next(data){
    var result = g.next(data);
    if (result.done) return result.value;
    result.value.then(function(data){
      next(data);
    });
  }

  next();
}

run(gen);
</code></pre>
<p>上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p>
<h3 id="co-">co模块的源码</h3>
<p>co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p>
<p>首先，co函数接受Generator函数作为参数，返回一个 Promise 对象。</p>
<pre><code class="lang-javascript">function co(gen) {
  var ctx = this;

  return new Promise(function(resolve, reject) {
  });
}
</code></pre>
<p>在返回的Promise对象里面，co先检查参数gen是否为Generator函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将Promise对象的状态改为resolved。</p>
<pre><code class="lang-javascript">function co(gen) {
  var ctx = this;

  return new Promise(function(resolve, reject) {
    if (typeof gen === &#39;function&#39;) gen = gen.call(ctx);
    if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen);
  });
}
</code></pre>
<p>接着，co将Generator函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。</p>
<pre><code class="lang-javascript">function co(gen) {
  var ctx = this;

  return new Promise(function(resolve, reject) {
    if (typeof gen === &#39;function&#39;) gen = gen.call(ctx);
    if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen);

    onFulfilled();
    function onFulfilled(res) {
      var ret;
      try {
        ret = gen.next(res);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }
  });
}
</code></pre>
<p>最后，就是关键的next函数，它会反复调用自身。</p>
<pre><code class="lang-javascript">function next(ret) {
  if (ret.done) return resolve(ret.value);
  var value = toPromise.call(ctx, ret.value);
  if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);
  return onRejected(new TypeError(&#39;You may only yield a function, promise, generator, array, or object, &#39;
    + &#39;but the following object was passed: &quot;&#39; + String(ret.value) + &#39;&quot;&#39;));
}
</code></pre>
<p>上面代码中，next 函数的内部代码，一共只有四行命令。</p>
<p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p>
<p>第二行，确保每一步的返回值，是 Promise 对象。</p>
<p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。</p>
<p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。</p>
<h3 id="-">处理并发的异步操作</h3>
<p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>
<p>这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。</p>
<pre><code class="lang-javascript">// 数组的写法
co(function* () {
  var res = yield [
    Promise.resolve(1),
    Promise.resolve(2)
  ];
  console.log(res);
}).catch(onerror);

// 对象的写法
co(function* () {
  var res = yield {
    1: Promise.resolve(1),
    2: Promise.resolve(2),
  };
  console.log(res);
}).catch(onerror);
</code></pre>
<p>下面是另一个例子。</p>
<pre><code class="lang-javascript">co(function* () {
  var values = [n1, n2, n3];
  yield values.map(somethingAsync);
});

function* somethingAsync(x) {
  // do something async
  return y
}
</code></pre>
<p>上面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。</p>
<h2 id="async-">async函数</h2>
<h3 id="-">含义</h3>
<p>ES7提供了<code>async</code>函数，使得异步操作变得更加方便。async 函数是什么？一句话，async函数就是Generator函数的语法糖。</p>
<p>前文有一个Generator函数，依次读取两个文件。</p>
<pre><code class="lang-javascript">var fs = require(&#39;fs&#39;);

var readFile = function (fileName){
  return new Promise(function (resolve, reject){
    fs.readFile(fileName, function(error, data){
      if (error) reject(error);
      resolve(data);
    });
  });
};

var gen = function* (){
  var f1 = yield readFile(&#39;/etc/fstab&#39;);
  var f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
};
</code></pre>
<p>写成 async 函数，就是下面这样。</p>
<pre><code class="lang-javascript">var asyncReadFile = async function (){
  var f1 = await readFile(&#39;/etc/fstab&#39;);
  var f2 = await readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
};
</code></pre>
<p>一比较就会发现，async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>async 函数对 Generator 函数的改进，体现在以下三点。</p>
<p>（1）内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块，而async 函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p>
<pre><code class="lang-javascript">var result = asyncReadFile();
</code></pre>
<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调用<code>next</code>方法，或者用co模块，才能得到真正执行，得到最后结果。</p>
<p>（2）更好的语义。<code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。 co模块约定，<code>yield</code>命令后面只能是Thunk函数或Promise对象，而<code>async</code>函数的<code>await</code>命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
<p>（4）返回值是Promise。async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>
<h3 id="async-">async函数的实现</h3>
<p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<pre><code class="lang-javascript">async function fn(args){
  // ...
}

// 等同于

function fn(args){
  return spawn(function*() {
    // ...
  });
}
</code></pre>
<p>所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p>
<p>下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。</p>
<pre><code class="lang-javascript">function spawn(genF) {
  return new Promise(function(resolve, reject) {
    var gen = genF();
    function step(nextF) {
      try {
        var next = nextF();
      } catch(e) {
        return reject(e);
      }
      if(next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(function(v) {
        step(function() { return gen.next(v); });
      }, function(e) {
        step(function() { return gen.throw(e); });
      });
    }
    step(function() { return gen.next(undefined); });
  });
}
</code></pre>
<p>async 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。</p>
<h3 id="async-">async 函数的用法</h3>
<p>同Generator函数一样，async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<p>下面是一个例子。</p>
<pre><code class="lang-javascript">async function getStockPriceByName(name) {
  var symbol = await getStockSymbol(name);
  var stockPrice = await getStockPrice(symbol);
  return stockPrice;
}

getStockPriceByName(&#39;goog&#39;).then(function (result){
  console.log(result);
});
</code></pre>
<p>上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。</p>
<p>下面的例子，指定多少毫秒后输出一个值。</p>
<pre><code class="lang-javascript">function timeout(ms) {
  return new Promise((resolve) =&gt; {
    setTimeout(resolve, ms);
  });
}

async function asyncPrint(value, ms) {
  await timeout(ms);
  console.log(value)
}

asyncPrint(&#39;hello world&#39;, 50);
</code></pre>
<p>上面代码指定50毫秒以后，输出&quot;hello world&quot;。</p>
<h3 id="-">注意点</h3>
<p>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。</p>
<pre><code class="lang-javascript">async function myFunction() {
  try {
    await somethingThatReturnsAPromise();
  } catch (err) {
    console.log(err);
  }
}

// 另一种写法

async function myFunction() {
  await somethingThatReturnsAPromise().catch(function (err){
    console.log(err);
  };
}
</code></pre>
<p>await命令只能用在async函数之中，如果用在普通函数，就会报错。</p>
<pre><code class="lang-javascript">async function dbFuc(db) {
  let docs = [{}, {}, {}];

  // 报错
  docs.forEach(function (doc) {
    await db.post(doc);
  });
}
</code></pre>
<p>上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。</p>
<pre><code class="lang-javascript">async function dbFuc(db) {
  let docs = [{}, {}, {}];

  // 可能得到错误结果
  docs.forEach(async function (doc) {
    await db.post(doc);
  });
}
</code></pre>
<p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。</p>
<pre><code class="lang-javascript">async function dbFuc(db) {
  let docs = [{}, {}, {}];

  for (let doc of docs) {
    await db.post(doc);
  }
}
</code></pre>
<p>如果确实希望多个请求并发执行，可以使用 Promise.all 方法。</p>
<pre><code class="lang-javascript">async function dbFuc(db) {
  let docs = [{}, {}, {}];
  let promises = docs.map((doc) =&gt; db.post(doc));

  let results = await Promise.all(promises);
  console.log(results);
}

// 或者使用下面的写法

async function dbFuc(db) {
  let docs = [{}, {}, {}];
  let promises = docs.map((doc) =&gt; db.post(doc));

  let results = [];
  for (let promise of promises) {
    results.push(await promise);
  }
  console.log(results);
}
</code></pre>
<p>ES6将await增加为保留字。使用这个词作为标识符，在ES5是合法的，在ES6将抛出SyntaxError。</p>
<h3 id="-promise-generator-">与Promise、Generator的比较</h3>
<p>我们通过一个例子，来看Async函数与Promise、Generator函数的区别。</p>
<p>假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<p>首先是Promise的写法。</p>
<pre><code class="lang-javascript">function chainAnimationsPromise(elem, animations) {

  // 变量ret用来保存上一个动画的返回值
  var ret = null;

  // 新建一个空的Promise
  var p = Promise.resolve();

  // 使用then方法，添加所有动画
  for(var anim in animations) {
    p = p.then(function(val) {
      ret = val;
      return anim(elem);
    })
  }

  // 返回一个部署了错误捕捉机制的Promise
  return p.catch(function(e) {
    /* 忽略错误，继续执行 */
  }).then(function() {
    return ret;
  });

}
</code></pre>
<p>虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来。</p>
<p>接着是Generator函数的写法。</p>
<pre><code class="lang-javascript">function chainAnimationsGenerator(elem, animations) {

  return spawn(function*() {
    var ret = null;
    try {
      for(var anim of animations) {
        ret = yield anim(elem);
      }
    } catch(e) {
      /* 忽略错误，继续执行 */
    }
      return ret;
  });

}
</code></pre>
<p>上面代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的spawn函数就是自动执行器，它返回一个Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise。</p>
<p>最后是Async函数的写法。</p>
<pre><code class="lang-javascript">async function chainAnimationsAsync(elem, animations) {
  var ret = null;
  try {
    for(var anim of animations) {
      ret = await anim(elem);
    }
  } catch(e) {
    /* 忽略错误，继续执行 */
  }
  return ret;
}
</code></pre>
<p>可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p>

		</article>
	</div>
</div>

    <footer id="footer">
        <i id="upToTop"></i>
        <p>
            <span>作者-阮一峰：<a href="http://es6.ruanyifeng.com/">http://es6.ruanyifeng.com/</a></span>|联系方式 <span>|</span> <a href="javascript:void(0);">yangxiaofuPL@163.com</a>
        </p>
    </footer>
    <script src="/booker/es6/dest/public/js/jquery-2.1.4.min.js"></script>
    <script src="/booker/es6/dest/public/js/highlight.min.js"></script>
    <script src="/booker/es6/dest/public/js/codepretty.js"></script>
</body>

</html>
