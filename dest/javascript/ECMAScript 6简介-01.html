<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>
        
	ECMAScript 6简介

    </title>
    <link rel="shortcut icon" href="/booker/es6/public/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="/booker/es6/public/css/public.css">
    <link rel="stylesheet" href="/booker/es6/public/css/page.css">
    <link rel="stylesheet" href="/booker/es6/public/css/monokai.min.css">
</head>

<body>
    <div id="headerWrapper" class="cf">
        <header id="header" class="cf">
            <div id="logo">
                <h1 class="logo">
					<a href="/"> 
	Learn ECMAScript6 the easy way
</a>
				</h1>
            </div>
        </header>
    </div>
    
<div id="pageWrapper">
	<div id="mainContent">
		<article class="post">
			<h1 id="ecmascript-6-">ECMAScript 6简介</h1>
<p>ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
<p>标准的制定者有计划，以后每年发布一次标准，使用年份作为标准的版本。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。也就是说，ES6就是ES2015，下一年应该会发布小幅修订的ES2016。</p>
<h2 id="ecmascript-javascript-">ECMAScript和JavaScript的关系</h2>
<p>一个常见的问题是，ECMAScript和JavaScript到底是什么关系？</p>
<p>要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。</p>
<p>该标准从一开始就是针对JavaScript语言制定的，但是之所以不叫JavaScript，有两个原因。一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。二是想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。在日常场合，这两个词是可以互换的。</p>
<h2 id="ecmascript-">ECMAScript的历史</h2>
<p>ES6从开始制定到最后发布，整整用了15年。</p>
<p>前面提到，ECMAScript 1.0是1997年发布的，接下来的两年，连续发布了ECMAScript 2.0（1998年6月）和ECMAScript 3.0（1999年12月）。3.0版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了JavaScript语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习JavaScript，其实就是在学3.0版的语法。</p>
<p>2000年，ECMAScript 4.0开始酝酿。这个版本最后没有通过，但是它的大部分内容被ES6继承了。因此，ES6制定的起点其实是2000年。</p>
<p>为什么ES4没有通过呢？因为这个版本太激进了，对ES3做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。</p>
<p>2007年10月，ECMAScript 4.0版草案发布，本来预计次年8月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。</p>
<p>2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。</p>
<p>2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。TC39委员会的总体考虑是，ES5与ES3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。当时，JavaScript.next指的是ES6，第六版发布以后，就指ES7。TC39的判断是，ES5会在2013年的年中成为JavaScript开发的主流标准，并在此后五年中一直保持这个位置。</p>
<p>2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。</p>
<p>2013年3月，ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。</p>
<p>2013年12月，ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。</p>
<p>2015年6月，ECMAScript 6正式通过，成为国际标准。从2000年算起，这时已经过去了15年。</p>
<h2 id="-">部署进度</h2>
<p>各大浏览器的最新版本，对ES6的支持可以查看<a href="http://kangax.github.io/es5-compat-table/es6/">kangax.github.io/es5-compat-table/es6/</a>。随着时间的推移，支持度已经越来越高了，ES6的大部分特性都实现了。</p>
<p>Node.js是JavaScript语言的服务器运行环境，对ES6的支持度比浏览器更高。通过Node，可以体验更多ES6的特性。建议使用版本管理工具<a href="https://github.com/creationix/nvm">nvm</a>，来安装Node，因为可以自由切换版本。不过，<code>nvm</code>不支持Windows系统，如果你使用Windows系统，下面的操作可以改用<a href="https://github.com/hakobera/nvmw">nvmw</a>或<a href="https://github.com/coreybutler/nvm-windows">nvm-windows</a>代替。</p>
<p>安装nvm需要打开命令行窗口，运行下面的命令。</p>
<pre><code class="lang-bash">$ curl -o https://raw.githubusercontent.com/creationix/nvm/&lt;version number&gt;/install.sh | bash
</code></pre>
<p>上面命令的<code>version number</code>处，需要用版本号替换。本节写作时的版本号是<code>v0.29.0</code>。该命令运行后，<code>nvm</code>会默认安装在用户主目录的<code>.nvm</code>子目录。</p>
<p>然后，激活<code>nvm</code>。</p>
<pre><code class="lang-bash">$ source ~/.nvm/nvm.sh
</code></pre>
<p>激活以后，安装Node的最新版。</p>
<pre><code class="lang-bash">$ nvm install node
</code></pre>
<p>安装完成后，切换到该版本。</p>
<pre><code class="lang-bash">$ nvm use node
</code></pre>
<p>使用下面的命令，可以查看Node所有已经实现的ES6特性。</p>
<pre><code class="lang-bash">$ node --v8-options | grep harmony

  --harmony_typeof
  --harmony_scoping
  --harmony_modules
  --harmony_symbols
  --harmony_proxies
  --harmony_collections
  --harmony_observation
  --harmony_generators
  --harmony_iteration
  --harmony_numeric_literals
  --harmony_strings
  --harmony_arrays
  --harmony_maths
  --harmony
</code></pre>
<p>上面命令的输出结果，会因为版本的不同而有所不同。</p>
<p>我写了一个<a href="https://github.com/ruanyf/es-checker">ES-Checker</a>模块，用来检查各种运行环境对ES6的支持情况。访问<a href="http://ruanyf.github.io/es-checker">ruanyf.github.io/es-checker</a>，可以看到您的浏览器支持ES6的程度。运行下面的命令，可以查看本机支持ES6的程度。</p>
<pre><code class="lang-bash">$ npm install -g es-checker
$ es-checker

=========================================
Passes 24 feature Dectations
Your runtime supports 57% of ECMAScript 6
=========================================
</code></pre>
<h2 id="babel-">Babel转码器</h2>
<p><a href="https://babeljs.io/">Babel</a>是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在浏览器或其他环境执行。这意味着，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。</p>
<pre><code class="lang-javascript">// 转码前
input.map(item =&gt; item + 1);

// 转码后
input.map(function (item) {
  return item + 1;
});
</code></pre>
<p>上面的原始代码用了箭头函数，这个特性还没有得到广泛支持，Babel将其转为普通函数，就能在现有的JavaScript环境执行了。</p>
<h3 id="-">命令行环境</h3>
<p>命令行下，Babel的安装命令如下。</p>
<pre><code class="lang-bash">$ npm install --global babel-cli
$ npm install --save babel-preset-es2015
</code></pre>
<p>然后在当前目录下，新建一个配置文件<code>.babelrc</code>。</p>
<pre><code class="lang-javascript">// .babelrc
{
  &quot;presets&quot;: [&#39;es2015&#39;]
}
</code></pre>
<p>Babel自带一个<code>babel-node</code>命令，提供支持ES6的REPL环境。它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。</p>
<pre><code class="lang-bash">$ babel-node
&gt;
&gt; console.log([1,2,3].map(x =&gt; x * x))
    [ 1, 4, 9 ]
&gt;
</code></pre>
<p><code>babel-node</code>命令也可以直接运行ES6脚本。假定将上面的代码放入脚本文件<code>es6.js</code>。</p>
<pre><code class="lang-bash">$ babel-node es6.js
[1, 4, 9]
</code></pre>
<p><code>babel</code>命令可以将ES6代码转为ES5代码。</p>
<pre><code class="lang-bash">$ babel es6.js
&quot;use strict&quot;;

console.log([1, 2, 3].map(function (x) {
  return x * x;
}));
</code></pre>
<p><code>-o</code>参数将转换后的代码，从标准输出导入文件。</p>
<pre><code class="lang-bash">$ babel es6.js -o es5.js
# 或者
$ babel es6.js --out-file es5.js
</code></pre>
<p><code>-d</code>参数用于转换整个目录。</p>
<pre><code class="lang-bash">$ babel -d build-dir source-dir
</code></pre>
<p>注意，<code>-d</code>参数后面跟的是输出目录。</p>
<p>如果希望生成source map文件，则要加上<code>-s</code>参数。</p>
<pre><code class="lang-bash">$ babel -d build-dir source-dir -s
</code></pre>
<h3 id="-">浏览器环境</h3>
<p>Babel也可以用于浏览器。但是，从Babel 6.0开始，不再直接提供浏览器版本，而是要用构建工具构建出来。如果你没有或不想使用构建工具，只有通过安装5.x版本的<code>babel-core</code>模块获取。</p>
<pre><code class="lang-bash">$ npm install babel-core@5
</code></pre>
<p>运行上面的命令以后，就可以在当前目录的<code>node_modules/babel-core/</code>子目录里面，找到<code>babel</code>的浏览器版本<code>browser.js</code>（未精简）和<code>browser.min.js</code>（已精简）。</p>
<p>然后，将下面的代码插入网页。</p>
<pre><code class="lang-html">&lt;script src=&quot;node_modules/babel-core/browser.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
// Your ES6 code
&lt;/script&gt;
</code></pre>
<p>上面代码中，<code>browser.js</code>是Babel提供的转换器脚本，可以在浏览器运行。用户的ES6脚本放在<code>script</code>标签之中，但是要注明<code>type=&quot;text/babel&quot;</code>。</p>
<p>这种写法是实时将ES6代码转为ES5，对网页性能会有影响。生产环境需要加载已经转码完成的脚本。</p>
<p>下面是<code>Babel</code>配合<code>Browserify</code>一起使用，可以生成浏览器能够直接加载的脚本。首先，安装<code>babelify</code>模块。</p>
<pre><code class="lang-bash">$ npm install --save-dev babelify babel-preset-es2015
</code></pre>
<p>然后，再用命令行转换ES6脚本。</p>
<pre><code class="lang-bash">$  browserify script.js -o bundle.js \
  -t [ babelify --presets [ es2015 react ] ]
</code></pre>
<p>上面代码将ES6脚本<code>script.js</code>，转为<code>bundle.js</code>，浏览器直接加载后者就可以了。</p>
<p>在<code>package.json</code>设置下面的代码，就不用每次命令行都输入参数了。</p>
<pre><code class="lang-javascript">{
  &quot;browserify&quot;: {
    &quot;transform&quot;: [[&quot;babelify&quot;, { &quot;presets&quot;: [&quot;es2015&quot;] }]]
  }
}
</code></pre>
<h3 id="node-">Node环境</h3>
<p>Node脚本之中，需要转换ES6脚本，可以像下面这样写。</p>
<p>先安装<code>babel-core</code>和<code>babel-preset-es2015</code>。</p>
<pre><code class="lang-javascript">$ npm install --save-dev babel-core babel-preset-es2015
</code></pre>
<p>然后，在项目根目录下新建一个<code>.babelrc</code>文件。</p>
<pre><code class="lang-javascript">{
  &quot;presets&quot;: [&quot;es2015&quot;]
}
</code></pre>
<p>然后在脚本中，调用<code>babel-core</code>的<code>transform</code>方法。</p>
<pre><code class="lang-javascript">var es5Code = &#39;let x = n =&gt; n + 1&#39;;
var es6Code = require(&#39;babel-core&#39;)
  .transform(es5Code, {presets: [&#39;es2015&#39;]})
  .code;
// &#39;&quot;use strict&quot;;\n\nvar x = function x(n) {\n  return n + 1;\n};&#39;
</code></pre>
<p>上面代码中，<code>transform</code>方法的第一个参数是一个字符串，表示需要转换的ES5代码，第二个参数是转换的配置对象。</p>
<p>Node脚本还有一种特殊的<code>babel</code>用法，即把<code>babel</code>加载为<code>require</code>命令的一个钩子。安装<code>babel-core</code>和<code>babel-preset-es2015</code>以后，先在项目的根目录下面，设置一个配置文件<code>.babelrc</code>。</p>
<pre><code class="lang-javascript">// .babelrc
{
  &quot;presets&quot;: [&quot;es2015&quot;]
}
</code></pre>
<p>然后，在你的应用的入口脚本（entry script）头部，加入下面的语句。</p>
<pre><code class="lang-javascript">require(&quot;babel-core/register&quot;);
</code></pre>
<p>有了上面这行语句，后面所有通过<code>require</code>命令加载的后缀名为<code>.es6</code>、<code>.es</code>、<code>.jsx</code>和<code>.js</code>的脚本，都会先通过<code>babel</code>转码后再加载。</p>
<p>需要注意的是，Babel默认不会转换Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code>）。如果你用到了这些功能，当前的运行环境又不支持。就需要安装<code>babel-polyfill</code>模块。</p>
<pre><code class="lang-bash">$ npm install babel-polyfill --save
</code></pre>
<p>然后，在所有脚本头部加上一行。</p>
<pre><code class="lang-javascript">require(&#39;babel-polyfill&#39;);
// 或者
import &#39;babel-polyfill&#39;;
</code></pre>
<h3 id="-">在线转换</h3>
<p>Babel提供一个<a href="https://babeljs.io/repl/">REPL在线编译器</a>，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行</p>
<h2 id="traceur-">Traceur转码器</h2>
<p>Google公司的<a href="https://github.com/google/traceur-compiler">Traceur</a>转码器，也可以将ES6代码转为ES5代码。</p>
<h3 id="-">直接插入网页</h3>
<p>Traceur允许将ES6代码直接插入网页。首先，必须在网页头部加载Traceur库文件。</p>
<pre><code class="lang-javascript">&lt;!-- 加载Traceur编译器 --&gt;
&lt;script src=&quot;http://google.github.io/traceur-compiler/bin/traceur.js&quot;
        type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;!-- 将Traceur编译器用于网页 --&gt;
&lt;script src=&quot;http://google.github.io/traceur-compiler/src/bootstrap.js&quot;
        type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;!-- 打开实验选项，否则有些特性可能编译不成功 --&gt;
&lt;script&gt;
        traceur.options.experimental = true;
&lt;/script&gt;
</code></pre>
<p>接下来，就可以把ES6代码放入上面这些代码的下方。</p>
<pre><code class="lang-javascript">&lt;script type=&quot;module&quot;&gt;
  class Calc {
    constructor(){
      console.log(&#39;Calc constructor&#39;);
    }
    add(a, b){
      return a + b;
    }
  }

  var c = new Calc();
  console.log(c.add(4,5));
&lt;/script&gt;
</code></pre>
<p>正常情况下，上面代码会在控制台打印出9。</p>
<p>注意，<code>script</code>标签的<code>type</code>属性的值是<code>module</code>，而不是<code>text/javascript</code>。这是Traceur编译器识别ES6代码的标识，编译器会自动将所有<code>type=module</code>的代码编译为ES5，然后再交给浏览器执行。</p>
<p>如果ES6代码是一个外部文件，也可以用<code>script</code>标签插入网页。</p>
<pre><code class="lang-javascript">&lt;script type=&quot;module&quot; src=&quot;calc.js&quot; &gt;
&lt;/script&gt;
</code></pre>
<h3 id="-">在线转换</h3>
<p>Traceur也提供一个<a href="http://google.github.io/traceur-compiler/demo/repl.html">在线编译器</a>，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。</p>
<p>上面的例子转为ES5代码运行，就是下面这个样子。</p>
<pre><code class="lang-javascript">&lt;script src=&quot;http://google.github.io/traceur-compiler/bin/traceur.js&quot;
        type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;http://google.github.io/traceur-compiler/src/bootstrap.js&quot;
        type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script&gt;
        traceur.options.experimental = true;
&lt;/script&gt;
&lt;script&gt;
$traceurRuntime.ModuleStore.getAnonymousModule(function() {
  &quot;use strict&quot;;

  var Calc = function Calc() {
    console.log(&#39;Calc constructor&#39;);
  };

  ($traceurRuntime.createClass)(Calc, {add: function(a, b) {
    return a + b;
  }}, {});

  var c = new Calc();
  console.log(c.add(4, 5));
  return {};
});
&lt;/script&gt;
</code></pre>
<h3 id="-">命令行转换</h3>
<p>作为命令行工具使用时，Traceur是一个Node.js的模块，首先需要用npm安装。</p>
<pre><code class="lang-bash">$ npm install -g traceur
</code></pre>
<p>安装成功后，就可以在命令行下使用traceur了。</p>
<p>traceur直接运行es6脚本文件，会在标准输出显示运行结果，以前面的<code>calc.js</code>为例。</p>
<pre><code class="lang-bash">$ traceur calc.js
Calc constructor
9
</code></pre>
<p>如果要将ES6脚本转为ES5保存，要采用下面的写法</p>
<pre><code class="lang-bash">$ traceur --script calc.es6.js --out calc.es5.js
</code></pre>
<p>上面代码的<code>--script</code>选项表示指定输入文件，<code>--out</code>选项表示指定输出文件。</p>
<p>为了防止有些特性编译不成功，最好加上<code>--experimental</code>选项。</p>
<pre><code class="lang-bash">$ traceur --script calc.es6.js --out calc.es5.js --experimental
</code></pre>
<p>命令行下转换的文件，就可以放到浏览器中运行。</p>
<h3 id="node-js-">Node.js环境的用法</h3>
<p>Traceur的Node.js用法如下（假定已安装traceur模块）。</p>
<pre><code class="lang-javascript">var traceur = require(&#39;traceur&#39;);
var fs = require(&#39;fs&#39;);

// 将ES6脚本转为字符串
var contents = fs.readFileSync(&#39;es6-file.js&#39;).toString();

var result = traceur.compile(contents, {
  filename: &#39;es6-file.js&#39;,
  sourceMap: true,
  // 其他设置
  modules: &#39;commonjs&#39;
});

if (result.error)
  throw result.error;

// result对象的js属性就是转换后的ES5代码
fs.writeFileSync(&#39;out.js&#39;, result.js);
// sourceMap属性对应map文件
fs.writeFileSync(&#39;out.js.map&#39;, result.sourceMap);
</code></pre>
<h2 id="ecmascript-7">ECMAScript 7</h2>
<p>2013年3月，ES6的草案封闭，不再接受新功能了。新的功能将被加入ES7。</p>
<p>任何人都可以向TC39提案，从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由TC39委员会批准。</p>
<ul>
<li>Stage 0 - Strawman（展示阶段）</li>
<li>Stage 1 - Proposal（征求意见阶段）</li>
<li>Stage 2 - Draft（草案阶段）</li>
<li>Stage 3 - Candidate（候选人阶段）</li>
<li>Stage 4 - Finished（定案阶段）</li>
</ul>
<p>一个提案只要能进入Stage 2，就差不多等于肯定会包括在ES7里面。</p>
<p>本书的写作目标之一，是跟踪ECMAScript语言的最新进展。对于那些明确的、或者很有希望列入ES7的功能，尤其是那些Babel已经支持的功能，都将予以介绍。</p>
<p>本书介绍的ES7功能清单如下。</p>
<p><strong>Stage 0</strong>：</p>
<ul>
<li>es7.comprehensions：数组推导</li>
<li>es7.classProperties：类的属性</li>
<li>es7.functionBind：函数的绑定运算符</li>
</ul>
<p><strong>Stage 1</strong>：</p>
<ul>
<li>es7.decorators：修饰器</li>
<li>es7.exportExtensions：export的扩展写法</li>
<li>es7.trailingFunctionCommas：函数参数的尾逗号</li>
</ul>
<p><strong>Stage 2</strong>：</p>
<ul>
<li>es7.exponentiationOperator：指数运算符</li>
<li>es7.asyncFunctions：async函数</li>
<li>es7.objectRestSpread：对象的Rest参数和扩展运算符</li>
</ul>
<p>ECMAScript当前的所有提案，可以在TC39的官方网站<a href="https://github.com/tc39/ecma262">Github.com/tc39/ecma262</a>查看。</p>
<p>Babel转码器可以通过安装和使用插件来使用各个stage的语言。</p>

		</article>
	</div>
</div>

    <footer id="footer">
        <i id="upToTop"></i>
        <p>
            <span>作者-阮一峰：<a href="http://es6.ruanyifeng.com/">http://es6.ruanyifeng.com/</a></span>|联系方式 <span>|</span> <a href="javascript:void(0);">yangxiaofuPL@163.com</a>
        </p>
    </footer>
    <script src="/booker/es6/public/js/jquery-2.1.4.min.js"></script>
    <script src="/booker/es6/public/js/highlight.min.js"></script>
    <script src="/booker/es6/public/js/codepretty.js"></script>
</body>

</html>
